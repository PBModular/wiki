# 📁 Multifiling

The main advantage of modules in the form of separate directories is the ability to organize the code in a straightforward way. The `ModuleExtension` class helps with this (as said before), which allows access to some attributes of the main class outside it (e.g. translations, database), as well as to register handler functions. So, let's create a new extension for our module.

Having created a new file, it is necessary to declare an extension class similar to module, only inherit `ModuleExtension` from `base.mod_ext`:


```python
from base.mod_ext import ModuleExtension
from base.module import command

from pyrogram.types import Message


class LogsExtension(ModuleExtension):
    @command('logs')
    async def logs_cmd(self, _, message: Message):
...
```
::: info
*Example of creating an extension*
:::

After creation, the extension must be registered in the main module class. This is done by overriding the property-method `module_extensions`:

```python
# Extensions
from .extensions.mod_manage import ModManageExtension
from .extensions.logs import LogsExtension
from .extensions.permissions import PermissionsExtension

class CoreModule(BaseModule):
    @property
    def module_extensions(self) -> list[Type[ModuleExtension]]:
        return [
            ModManageExtension,
            LogsExtension,
            PermissionsExtension
        ]
```
