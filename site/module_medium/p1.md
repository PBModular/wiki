# üíª Initial structure and a simple handler

The structure of the module was described in the previous section. Now let's move on to its creation!

**Check out the** [**pyrogram documentation**](https://docs.pyrogram.org/) **first, this only describes the specifics of writing for PBModular!**

Following the example from the previous section, create the module directory. Now we need to write a command, let it be `/hello`. Let the bot respond "Hello World" to this command.

```python
async def on_hello(self, bot: Client, message: Message):
    await message.reply("Hello World!")
```

Fine. However, the bot doesn't know that this command is declared, the function needs to be registered as a command handler. This is done by using one of 3 decorators that let the module class know that this method is a command handler: `@command`, `@callback_query`, `@message`.

The `@command` decorator takes as arguments a list or a single command to which the bot will respond, and an optional [Pyrogram filter.](https://docs.pyrogram.org/topics/use-filters) The `@callback_query` is for handling button events, `@message` is for handling any messages. The Pyrogram filter is accepted in the arguments, even though it is optional, it is highly recommended to install it!

So, we import the `@command` decorator from `base.module`, and use it!

```python
from base.module import command
...
@command("hello")
async def on_hello(self, bot: Client, message: Message):
    await message.reply("Hello World!")

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å —Ñ–∏–ª—å—Ç—Ä–æ–º
from pyrogram import filters
...
@command("start", filters.regex(r"/start \w+$"))
```
::: info
Initially there was registration of commands based on function name, as implemented in the FTG userbot and its forks. However, in the course of development it was recognized as an inconvenient and non-obvious way of registration
:::
