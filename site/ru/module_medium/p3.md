# 📁 Многофайловость

Главный плюс модулей в виде отдельных директорий - возможность разложить код по полочкам. Помогает с этим (как сказано раньше) класс `ModuleExtension`, который позволяет получать доступ к некоторым атрибутам основного класса вне него (напр. переводы, база данных), а так же регистрировать функции-обработчики. Так что, создадим новое расширение для нашего модуля.

Создав новый файл, необходимо объявить класс расширения по аналогии с модулем, только наследовать уже `ModuleExtension` из `base.mod_ext`:


```python
from base.mod_ext import ModuleExtension
from base.module import command

from pyrogram.types import Message


class LogsExtension(ModuleExtension):
    @command('logs')
    async def logs_cmd(self, _, message: Message):
...
```
::: info
**Пример создания расширения**
:::

После создания расширение необходимо зарегистрировать в основном классе модуля. Делается это при помощи переопределения property-метода `module_extensions`:

```python
# Extensions
from .extensions.mod_manage import ModManageExtension
from .extensions.logs import LogsExtension
from .extensions.permissions import PermissionsExtension

class CoreModule(BaseModule):
    @property
    def module_extensions(self) -> list[Type[ModuleExtension]]:
        return [
            ModManageExtension,
            LogsExtension,
            PermissionsExtension
        ]
```
